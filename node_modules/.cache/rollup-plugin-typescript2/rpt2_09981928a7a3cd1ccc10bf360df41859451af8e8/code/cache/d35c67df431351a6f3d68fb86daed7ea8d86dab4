{"code":"import { MoveViewPortBehavior } from '../behaviors/move-view-port-behavior';\r\nimport { SelectStepBehavior } from '../behaviors/select-step-behavior';\r\nimport { race } from '../core/simple-event-race';\r\nimport { Vector } from '../core/vector';\r\nimport { StepComponentState } from './component';\r\nimport { WorkspaceView } from './workspace-view';\r\nconst WHEEL_DELTA = 0.1;\r\nconst ZOOM_DELTA = 0.2;\r\nexport class Workspace {\r\n    constructor(view, context) {\r\n        this.view = view;\r\n        this.context = context;\r\n        this.isValid = false;\r\n        this.selectedStepComponent = null;\r\n    }\r\n    static create(parent, context) {\r\n        const view = WorkspaceView.create(parent, context.configuration.steps);\r\n        const workspace = new Workspace(view, context);\r\n        setTimeout(() => {\r\n            workspace.render();\r\n            workspace.resetViewPort();\r\n        });\r\n        context.setProvider(workspace);\r\n        context.onViewPortChanged.subscribe(vp => workspace.onViewPortChanged(vp));\r\n        context.onIsDraggingChanged.subscribe(i => workspace.onIsDraggingChanged(i));\r\n        context.onIsSmartEditorCollapsedChanged.subscribe(() => workspace.onIsSmartEditorCollapsedChanged());\r\n        race(0, context.onDefinitionChanged, context.onSelectedStepChanged).subscribe(r => {\r\n            const [defChangedDetails, selectedStep] = r;\r\n            if (defChangedDetails) {\r\n                if (defChangedDetails.rerender) {\r\n                    workspace.render();\r\n                }\r\n                else {\r\n                    workspace.revalidate();\r\n                }\r\n            }\r\n            else if (selectedStep !== undefined) {\r\n                workspace.onSelectedStepChanged(selectedStep);\r\n            }\r\n        });\r\n        view.bindMouseDown((p, t, b) => workspace.onMouseDown(p, t, b));\r\n        view.bindTouchStart(e => workspace.onTouchStart(e));\r\n        view.bindContextMenu(e => workspace.onContextMenu(e));\r\n        view.bindWheel(e => workspace.onWheel(e));\r\n        return workspace;\r\n    }\r\n    render() {\r\n        this.view.render(this.context.definition.sequence, this.context.definition.properties.journeyId);\r\n        this.trySelectStep(this.context.selectedStep);\r\n        this.revalidate();\r\n    }\r\n    getPlaceholders() {\r\n        const result = [];\r\n        this.getRootComponent().getPlaceholders(result);\r\n        return result;\r\n    }\r\n    getSelectedStepComponent() {\r\n        if (this.selectedStepComponent) {\r\n            return this.selectedStepComponent;\r\n        }\r\n        throw new Error('Nothing selected');\r\n    }\r\n    getComponentByStepId(stepId) {\r\n        const component = this.getRootComponent().findById(stepId);\r\n        if (!component) {\r\n            throw new Error(`Cannot find component for step id: ${stepId}`);\r\n        }\r\n        return component;\r\n    }\r\n    resetViewPort() {\r\n        const rcv = this.getRootComponent().view;\r\n        const clientSize = this.view.getClientSize();\r\n        const x = Math.max(0, (clientSize.x - rcv.width) / 2);\r\n        const y = Math.max(0, (clientSize.y - rcv.height) / 2);\r\n        this.context.setViewPort(new Vector(x, y), 1);\r\n    }\r\n    zoom(direction) {\r\n        const delta = direction ? ZOOM_DELTA : -ZOOM_DELTA;\r\n        const scale = this.context.limitScale(this.context.viewPort.scale + delta);\r\n        this.context.setViewPort(this.context.viewPort.position, scale);\r\n    }\r\n    moveViewPortToStep(stepComponent) {\r\n        const vp = this.context.viewPort;\r\n        const componentPosition = stepComponent.view.getClientPosition();\r\n        const clientSize = this.view.getClientSize();\r\n        const realPos = vp.position.divideByScalar(vp.scale).subtract(componentPosition.divideByScalar(vp.scale));\r\n        const componentOffset = new Vector(stepComponent.view.width, stepComponent.view.height).divideByScalar(2);\r\n        this.context.animateViewPort(realPos.add(clientSize.divideByScalar(2)).subtract(componentOffset), 1);\r\n    }\r\n    destroy() {\r\n        this.view.destroy();\r\n    }\r\n    revalidate() {\r\n        this.isValid = this.getRootComponent().validate();\r\n    }\r\n    onMouseDown(position, target, button) {\r\n        const isPrimaryButton = button === 0;\r\n        const isMiddleButton = button === 1;\r\n        if (isPrimaryButton || isMiddleButton) {\r\n            this.startBehavior(target, position, isMiddleButton);\r\n        }\r\n    }\r\n    onTouchStart(position) {\r\n        const element = document.elementFromPoint(position.x, position.y);\r\n        if (element) {\r\n            this.startBehavior(element, position, false);\r\n        }\r\n    }\r\n    onContextMenu(e) {\r\n        e.preventDefault();\r\n    }\r\n    startBehavior(target, position, forceMoveMode) {\r\n        const clickedStep = !forceMoveMode && !this.context.isMoveModeEnabled ? this.getRootComponent().findByElement(target) : null;\r\n        if (clickedStep) {\r\n            this.context.behaviorController.start(position, SelectStepBehavior.create(clickedStep, this.context));\r\n        }\r\n        else {\r\n            this.context.behaviorController.start(position, MoveViewPortBehavior.create(this.context));\r\n        }\r\n    }\r\n    onWheel(e) {\r\n        const viewPort = this.context.viewPort;\r\n        const mousePoint = new Vector(e.pageX, e.pageY).subtract(this.view.getClientPosition());\r\n        // The real point is point on canvas with no scale.\r\n        const mouseRealPoint = mousePoint.divideByScalar(viewPort.scale).subtract(viewPort.position.divideByScalar(viewPort.scale));\r\n        const wheelDelta = e.deltaY > 0 ? -WHEEL_DELTA : WHEEL_DELTA;\r\n        const newScale = this.context.limitScale(viewPort.scale + wheelDelta);\r\n        const position = mouseRealPoint.multiplyByScalar(-newScale).add(mousePoint);\r\n        const scale = newScale;\r\n        this.context.setViewPort(position, scale);\r\n    }\r\n    onIsDraggingChanged(isDragging) {\r\n        this.getRootComponent().setIsDragging(isDragging);\r\n    }\r\n    onIsSmartEditorCollapsedChanged() {\r\n        setTimeout(() => this.view.refreshSize());\r\n    }\r\n    onViewPortChanged(viewPort) {\r\n        this.view.setPositionAndScale(viewPort.position, viewPort.scale);\r\n    }\r\n    onSelectedStepChanged(step) {\r\n        this.trySelectStep(step);\r\n    }\r\n    trySelectStep(step) {\r\n        if (this.selectedStepComponent) {\r\n            this.selectedStepComponent.setState(StepComponentState.default);\r\n            this.selectedStepComponent = null;\r\n        }\r\n        if (step) {\r\n            this.selectedStepComponent = this.getRootComponent().findById(step.id);\r\n            if (!this.selectedStepComponent) {\r\n                throw new Error(`Cannot find a step component by id ${step.id}`);\r\n            }\r\n            this.selectedStepComponent.setState(StepComponentState.selected);\r\n        }\r\n    }\r\n    getRootComponent() {\r\n        if (this.view.rootComponent) {\r\n            return this.view.rootComponent;\r\n        }\r\n        throw new Error('Root component not found');\r\n    }\r\n}\r\n","references":["/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/behaviors/move-view-port-behavior.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/behaviors/select-step-behavior.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/simple-event-race.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/vector.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/definition.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/designer-context.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/workspace/component.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/workspace/start-stop/start-component.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/workspace/workspace-view.ts"],"dts":{"name":"/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/build/src/workspace/workspace.d.ts","writeByteOrderMark":false,"text":"import { DesignerComponentProvider, DesignerContext } from '../designer-context';\r\nimport { Placeholder, StepComponent } from './component';\r\nexport declare class Workspace implements DesignerComponentProvider {\r\n    private readonly view;\r\n    private readonly context;\r\n    static create(parent: HTMLElement, context: DesignerContext): Workspace;\r\n    isValid: boolean;\r\n    private selectedStepComponent;\r\n    private constructor();\r\n    render(): void;\r\n    getPlaceholders(): Placeholder[];\r\n    getSelectedStepComponent(): StepComponent;\r\n    getComponentByStepId(stepId: string): StepComponent;\r\n    resetViewPort(): void;\r\n    zoom(direction: boolean): void;\r\n    moveViewPortToStep(stepComponent: StepComponent): void;\r\n    destroy(): void;\r\n    private revalidate;\r\n    private onMouseDown;\r\n    private onTouchStart;\r\n    private onContextMenu;\r\n    private startBehavior;\r\n    private onWheel;\r\n    private onIsDraggingChanged;\r\n    private onIsSmartEditorCollapsedChanged;\r\n    private onViewPortChanged;\r\n    private onSelectedStepChanged;\r\n    private trySelectStep;\r\n    private getRootComponent;\r\n}\r\n"}}
