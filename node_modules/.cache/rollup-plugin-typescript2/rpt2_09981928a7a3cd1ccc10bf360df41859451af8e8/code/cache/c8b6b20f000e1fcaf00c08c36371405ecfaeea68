{"code":"import { animate } from './core/animation';\r\nimport { SequenceModifier } from './core/sequence-modifier';\r\nimport { SimpleEvent } from './core/simple-event';\r\nimport { Vector } from './core/vector';\r\nimport { ComponentType } from './definition';\r\nimport { Dom } from './core/dom';\r\nconst MIN_SCALE = 0.1;\r\nconst MAX_SCALE = 3;\r\nexport class DesignerContext {\r\n    constructor(definition, behaviorController, layoutController, configuration, isToolboxCollapsed, isSmartEditorCollapsed) {\r\n        this.definition = definition;\r\n        this.behaviorController = behaviorController;\r\n        this.layoutController = layoutController;\r\n        this.configuration = configuration;\r\n        this.isToolboxCollapsed = isToolboxCollapsed;\r\n        this.isSmartEditorCollapsed = isSmartEditorCollapsed;\r\n        this.onViewPortChanged = new SimpleEvent();\r\n        this.onSelectedStepChanged = new SimpleEvent();\r\n        this.onIsReadonlyChanged = new SimpleEvent();\r\n        this.onIsDraggingChanged = new SimpleEvent();\r\n        this.onIsMoveModeEnabledChanged = new SimpleEvent();\r\n        this.onIsToolboxCollapsedChanged = new SimpleEvent();\r\n        this.onIsSmartEditorCollapsedChanged = new SimpleEvent();\r\n        this.onDefinitionChanged = new SimpleEvent();\r\n        this.viewPort = {\r\n            position: new Vector(0, 0),\r\n            scale: 1\r\n        };\r\n        this.selectedStep = null;\r\n        this.isDragging = false;\r\n        this.isMoveModeEnabled = false;\r\n        this.isReadonly = !!configuration.isReadonly;\r\n    }\r\n    setViewPort(position, scale) {\r\n        this.viewPort = { position, scale };\r\n        this.onViewPortChanged.forward(this.viewPort);\r\n    }\r\n    resetViewPort() {\r\n        this.getProvider().resetViewPort();\r\n    }\r\n    animateViewPort(position, scale) {\r\n        if (this.viewPortAnimation && this.viewPortAnimation.isAlive) {\r\n            this.viewPortAnimation.stop();\r\n        }\r\n        const startPosition = this.viewPort.position;\r\n        const startScale = this.viewPort.scale;\r\n        const deltaPosition = startPosition.subtract(position);\r\n        const deltaScale = startScale - scale;\r\n        this.viewPortAnimation = animate(150, progress => {\r\n            const newScale = startScale - deltaScale * progress;\r\n            this.setViewPort(startPosition.subtract(deltaPosition.multiplyByScalar(progress)), newScale);\r\n        });\r\n    }\r\n    moveViewPortToStep(stepId) {\r\n        const component = this.getProvider().getComponentByStepId(stepId);\r\n        this.getProvider().moveViewPortToStep(component);\r\n    }\r\n    limitScale(scale) {\r\n        return Math.min(Math.max(scale, MIN_SCALE), MAX_SCALE);\r\n    }\r\n    zoom(direction) {\r\n        this.getProvider().zoom(direction);\r\n    }\r\n    setSelectedStep(step) {\r\n        if (this.selectedStep !== step) {\r\n            this.selectedStep = step;\r\n            this.onSelectedStepChanged.forward(step);\r\n        }\r\n    }\r\n    selectStepById(stepId) {\r\n        const component = this.getProvider().getComponentByStepId(stepId);\r\n        this.setSelectedStep(component.step);\r\n    }\r\n    tryInsertStep(step, targetSequence, targetIndex) {\r\n        const canInsertStep = this.configuration.steps.canInsertStep\r\n            ? this.configuration.steps.canInsertStep(step, targetSequence, targetIndex)\r\n            : true;\r\n        if (!canInsertStep) {\r\n            return false;\r\n        }\r\n        SequenceModifier.insertStep(step, targetSequence, targetIndex);\r\n        this.notifiyDefinitionChanged(true);\r\n        this.setSelectedStep(step);\r\n        return true;\r\n    }\r\n    tryMoveStep(sourceSequence, step, targetSequence, targetIndex) {\r\n        const canMoveStep = this.configuration.steps.canMoveStep\r\n            ? this.configuration.steps.canMoveStep(sourceSequence, step, targetSequence, targetIndex)\r\n            : true;\r\n        if (!canMoveStep) {\r\n            return false;\r\n        }\r\n        SequenceModifier.moveStep(sourceSequence, step, targetSequence, targetIndex);\r\n        this.notifiyDefinitionChanged(true);\r\n        this.setSelectedStep(step);\r\n        return true;\r\n    }\r\n    tryDeleteStep(step) {\r\n        var _a;\r\n        const component = this.getProvider().getComponentByStepId(step.id);\r\n        const canDeleteStep = this.configuration.steps.canDeleteStep\r\n            ? this.configuration.steps.canDeleteStep(component.step, component.parentSequence)\r\n            : true;\r\n        if (!canDeleteStep) {\r\n            return false;\r\n        }\r\n        promptChoices(this, component);\r\n        this.notifiyDefinitionChanged(true);\r\n        if (((_a = this.selectedStep) === null || _a === void 0 ? void 0 : _a.id) === step.id) {\r\n            this.setSelectedStep(null);\r\n        }\r\n        return true;\r\n    }\r\n    setIsReadonly(isReadonly) {\r\n        this.isReadonly = isReadonly;\r\n        this.onIsReadonlyChanged.forward(isReadonly);\r\n    }\r\n    setIsDragging(isDragging) {\r\n        this.isDragging = isDragging;\r\n        this.onIsDraggingChanged.forward(isDragging);\r\n    }\r\n    toggleIsMoveModeEnabled() {\r\n        this.isMoveModeEnabled = !this.isMoveModeEnabled;\r\n        this.onIsMoveModeEnabledChanged.forward(this.isMoveModeEnabled);\r\n    }\r\n    toggleIsToolboxCollapsed() {\r\n        this.isToolboxCollapsed = !this.isToolboxCollapsed;\r\n        this.onIsToolboxCollapsedChanged.forward(this.isToolboxCollapsed);\r\n    }\r\n    toggleIsSmartEditorCollapsed() {\r\n        this.isSmartEditorCollapsed = !this.isSmartEditorCollapsed;\r\n        this.onIsSmartEditorCollapsedChanged.forward(this.isSmartEditorCollapsed);\r\n    }\r\n    notifiyDefinitionChanged(rerender) {\r\n        this.onDefinitionChanged.forward({ rerender });\r\n    }\r\n    getPlaceholders() {\r\n        return this.getProvider().getPlaceholders();\r\n    }\r\n    setProvider(provider) {\r\n        this.provider = provider;\r\n    }\r\n    getProvider() {\r\n        if (!this.provider) {\r\n            throw new Error('Provider is not set');\r\n        }\r\n        return this.provider;\r\n    }\r\n}\r\nfunction promptChoices(context, component) {\r\n    //console.log(controller);\r\n    let output = \"\";\r\n    // Create a propmt window\r\n    const dialogBox = Dom.element('dialog', {\r\n        class: 'confirm-dialog',\r\n        id: 'dialog-box'\r\n    });\r\n    const title = Dom.element('h3', {\r\n        class: 'confirm-dialog-content'\r\n    });\r\n    let toDo;\r\n    // A form to include all choices\r\n    const form = Dom.element('form', {\r\n        method: 'dialog',\r\n        id: 'dialog-form'\r\n    });\r\n    if (component.step.componentType == ComponentType.switch) {\r\n        toDo = ['Delete true path', 'Delete false path', 'Delete both'];\r\n        title.innerText = \"Which branch do you want to delete?\";\r\n        for (let i = 0; i < toDo.length; i++) {\r\n            const radio = Dom.element('input', {\r\n                type: 'radio',\r\n                name: 'choice',\r\n                value: i\r\n            });\r\n            const choice = Dom.element('label');\r\n            choice.innerText = toDo[i];\r\n            form.appendChild(radio);\r\n            form.appendChild(choice);\r\n            choice.insertAdjacentHTML(\"afterend\", \"</br>\");\r\n        }\r\n    }\r\n    else {\r\n        title.innerText = \"Are you sure to delete this block?\";\r\n    }\r\n    dialogBox.appendChild(title);\r\n    const btn1 = Dom.element('button', {\r\n        type: 'submit'\r\n    });\r\n    btn1.innerText = 'Confirm';\r\n    form.appendChild(btn1);\r\n    const btn2 = Dom.element('button', {\r\n        type: 'submit'\r\n    });\r\n    btn2.innerText = 'Cancel';\r\n    btn2.addEventListener('click', function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log(context.layoutController.getParent().childNodes);\r\n        const designer = document.getElementById('designer');\r\n        if (designer != null) {\r\n            designer.removeChild(designer.childNodes[1]);\r\n        }\r\n    });\r\n    form.appendChild(btn2);\r\n    dialogBox.appendChild(form);\r\n    context.layoutController.getParent().appendChild(dialogBox);\r\n    //console.log(dialogBox);\r\n    if (typeof dialogBox.showModal === \"function\") {\r\n        dialogBox.showModal();\r\n    }\r\n    else {\r\n        prompt(\"Wow from prompt window\", 'ok');\r\n    }\r\n    btn1.addEventListener('click', function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log(component);\r\n        if (component.step.componentType == \"switch\") {\r\n            var elem = document.getElementsByTagName('input');\r\n            for (let i = 0; i < elem.length; i++) {\r\n                // console.log(570, elem);\r\n                if (elem[i].type == 'radio' && elem[i].checked) {\r\n                    output = elem[i].value;\r\n                }\r\n            }\r\n            // SequenceModifier.deleteSwitchStep(component.step, component.parentSequence, output); \r\n        }\r\n        else {\r\n            // Delete behavior\r\n            output = \"2\";\r\n        }\r\n        SequenceModifier.deleteStep(component.step, component.parentSequence, output);\r\n        if (context.provider != undefined) {\r\n            context.provider.render();\r\n        }\r\n        const designer = document.getElementById('designer');\r\n        if (designer != null) {\r\n            designer.removeChild(designer.childNodes[1]);\r\n        }\r\n    });\r\n}\r\n","references":["/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/behaviors/behavior-controller.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/animation.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/sequence-modifier.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/simple-event.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/vector.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/definition.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/designer-configuration.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/layout-controller.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/workspace/component.ts","/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/src/core/dom.ts"],"dts":{"name":"/Users/mm/Documents/IntelliProIntern/sequential-flow-chart-front-end/build/src/designer-context.d.ts","writeByteOrderMark":false,"text":"import { BehaviorController } from './behaviors/behavior-controller';\r\nimport { SimpleEvent } from './core/simple-event';\r\nimport { Vector } from './core/vector';\r\nimport { Definition, Sequence, Step } from './definition';\r\nimport { DesignerConfiguration } from './designer-configuration';\r\nimport { LayoutController } from './layout-controller';\r\nimport { Placeholder, StepComponent } from './workspace/component';\r\nexport interface DefinitionChangedEvent {\r\n    rerender: boolean;\r\n}\r\nexport declare class DesignerContext {\r\n    readonly definition: Definition;\r\n    readonly behaviorController: BehaviorController;\r\n    readonly layoutController: LayoutController;\r\n    readonly configuration: DesignerConfiguration;\r\n    isToolboxCollapsed: boolean;\r\n    isSmartEditorCollapsed: boolean;\r\n    readonly onViewPortChanged: SimpleEvent<ViewPort>;\r\n    readonly onSelectedStepChanged: SimpleEvent<Step | null>;\r\n    readonly onIsReadonlyChanged: SimpleEvent<boolean>;\r\n    readonly onIsDraggingChanged: SimpleEvent<boolean>;\r\n    readonly onIsMoveModeEnabledChanged: SimpleEvent<boolean>;\r\n    readonly onIsToolboxCollapsedChanged: SimpleEvent<boolean>;\r\n    readonly onIsSmartEditorCollapsedChanged: SimpleEvent<boolean>;\r\n    readonly onDefinitionChanged: SimpleEvent<DefinitionChangedEvent>;\r\n    viewPort: ViewPort;\r\n    selectedStep: Step | null;\r\n    isReadonly: boolean;\r\n    isDragging: boolean;\r\n    isMoveModeEnabled: boolean;\r\n    private viewPortAnimation?;\r\n    provider?: DesignerComponentProvider;\r\n    constructor(definition: Definition, behaviorController: BehaviorController, layoutController: LayoutController, configuration: DesignerConfiguration, isToolboxCollapsed: boolean, isSmartEditorCollapsed: boolean);\r\n    setViewPort(position: Vector, scale: number): void;\r\n    resetViewPort(): void;\r\n    animateViewPort(position: Vector, scale: number): void;\r\n    moveViewPortToStep(stepId: string): void;\r\n    limitScale(scale: number): number;\r\n    zoom(direction: boolean): void;\r\n    setSelectedStep(step: Step | null): void;\r\n    selectStepById(stepId: string): void;\r\n    tryInsertStep(step: Step, targetSequence: Sequence, targetIndex: number): boolean;\r\n    tryMoveStep(sourceSequence: Sequence, step: Step, targetSequence: Sequence, targetIndex: number): boolean;\r\n    tryDeleteStep(step: Step): boolean;\r\n    setIsReadonly(isReadonly: boolean): void;\r\n    setIsDragging(isDragging: boolean): void;\r\n    toggleIsMoveModeEnabled(): void;\r\n    toggleIsToolboxCollapsed(): void;\r\n    toggleIsSmartEditorCollapsed(): void;\r\n    notifiyDefinitionChanged(rerender: boolean): void;\r\n    getPlaceholders(): Placeholder[];\r\n    setProvider(provider: DesignerComponentProvider): void;\r\n    private getProvider;\r\n}\r\nexport interface ViewPort {\r\n    position: Vector;\r\n    scale: number;\r\n}\r\nexport interface DesignerComponentProvider {\r\n    getPlaceholders(): Placeholder[];\r\n    getComponentByStepId(stepId: string): StepComponent;\r\n    resetViewPort(): void;\r\n    zoom(direction: boolean): void;\r\n    moveViewPortToStep(stepComponent: StepComponent): void;\r\n    render(): void;\r\n}\r\n"}}
